import java.util.ArrayList;
import java.util.Random;

public class GSA extends binMeta {

	/**
	 * FITNESS : fontion qui evalue les element de l'ensemble
	 * @param x
	 * @param y
	 * @param z
	 * @return
	 */
	public int fitness(int x , int y, int z) {
		
		
		return 0;
	}
	
	
	
	//Data contienderais une liste d'entier (ArrayList) qui aurait cette structure:
	//  X taille max            ,   Y taille max          ,   Z taille max
	//  1er element position X    1er element position Y    1er element position Z
	// 2eme element position X , ....
	public GSA(Data data, Objective obj , long maxTime) {
	      try
	      {
	    	  
	    	  String msg = "Impossible de crée un objet GSA : ";
	    	  if(maxTime <= 0) throw new Exception(msg + " Le temps d'execution max est de 0 ou est Négatif");	    	  
	    	  this.maxTime = maxTime;
	    	  if (data == null) throw new Exception(msg + "les data sont Null");
	    	  this.solution = data;
	    	  if(obj == null) throw new Exception(" L'objectif donner est null");
	    	  this.obj=obj;
	    	  this.objValue = objValue;
	    	  this.metaName = "Gravitational Search Algorithm";
	    	  
	    	  //Fitness
	    	  
	    	  
	    	  
	    	  /*
	         String msg = "Impossible to create RandomWalk object: ";
	         if (maxTime <= 0) throw new Exception(msg + "the maximum execution time is 0 or even negative");
	         this.maxTime = maxTime;
	         if (data == null) throw new Exception(msg + "the reference to the starting point is null");
	         this.solution = data;
	         if (obj == null) throw new Exception(msg + "the reference to the objective is null");
	         this.obj = obj;
	         this.objValue = this.obj.value(this.solution);
	         this.metaName = "RandomWalk";
	         */
	      }
	      catch (Exception e)
	      {
	         e.printStackTrace();
	         System.exit(1);
	      }
	}
	
	
	@Override
	public void optimize() {
		// TODO Auto-generated method stub
		 Random R = new Random();
	     Data D = new Data(this.solution);
	     long startime = System.currentTimeMillis();

	      // main loop
	      while (System.currentTimeMillis() - startime < this.maxTime)
	      {
	         // a new solution is generated by flipping a consecutive subset of its bits
	         ArrayList<Data> lD = new ArrayList<Data>();
	         int n = D.numberOfBits();
	         int i = R.nextInt(n);
	         if (i != 0 && i != n - 1)
	         {
	            int j = i + 1 + R.nextInt(n - i - 1);
	            if (j != n - 1)
	            {
	               lD.add(new Data(D,0,i-1));
	               lD.add(new Data(D,i,j-1,true));
	               lD.add(new Data(D,j,n-1));
	               D = new Data(lD);
	            }
	            else
	            {
	               lD.add(new Data(D,0,i-1,true));
	               lD.add(new Data(D,i,n-1));
	               D = new Data(lD);
	            }
	         }
	         else
	         {
	            int j = 1 + R.nextInt(n - 2);
	            lD.add(new Data(D,0,j-1));
	            lD.add(new Data(D,j,n-1,true));
	            D = new Data(lD);
	         }

	         double value = obj.value(D);
	         if (this.objValue > value)
	         {
	            this.objValue = value;
	            this.solution = new Data(D);
	         }
	      }
	}

	   // main
	   public static void main(String[] args) {
	   
		   
		// BitCounter
		   
		   

		// Fermat
		   
		   
		   
		// ColorPartition
		   
	   }
	   
}
